// This shader applies a Sobel filter to detect edges in the image.
// The Sobel filter extracts the first order derivates of the image,
// that is, the slope. Where the slope is sharp there is an edge.
// These are the filter kernels:
//
//  SobelX       SobelY
//  1  0 -1      1  2  1
//  2  0 -2      0  0  0
//  1  0 -1     -1 -2 -1

float4 main(float4 texCoord1: TEXCOORD0,
            float4 texCoord2: TEXCOORD1,
            float4 texCoord3: TEXCOORD2,
            float4 texCoord4: TEXCOORD3,

            uniform sampler2D normalBuffer: TEXUNIT0) : COLOR
{
  // sample neighbor normals
  float3 s[3][3];
  s[0][0] = tex2D(normalBuffer, texCoord1.xy).rgb;
  s[0][1] = tex2D(normalBuffer, texCoord1.zw).rgb;
  s[0][2] = tex2D(normalBuffer, texCoord2.xy).rgb;
  s[1][0] = tex2D(normalBuffer, texCoord2.zw).rgb;
  s[1][2] = tex2D(normalBuffer, texCoord3.xy).rgb;
  s[2][0] = tex2D(normalBuffer, texCoord3.zw).rgb;
  s[2][1] = tex2D(normalBuffer, texCoord4.xy).rgb;
  s[2][2] = tex2D(normalBuffer, texCoord4.zw).rgb;

  // Sobel filter in X direction
  float3 sobelX = s[0][0] + 2 * s[1][0] + s[2][0] - s[0][2] - 2 * s[1][2] - s[2][2];
  // Sobel filter in Y direction
  float3 sobelY = s[0][0] + 2 * s[0][1] + s[0][2] - s[2][0] - 2 * s[2][1] - s[2][2];

  // Find edge
  float3 edgeSqr = (sobelX * sobelX + sobelY * sobelY);
  float value = dot(edgeSqr, float3(1));
  return float4(0, 0, 0, value * 0.1);
}
